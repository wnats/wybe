# purpose: Standard Count L/ibrary, an unsigned integer
# since  : 0.1

pragma no_standard_library  # Standard library can't depend on itself!

use wybe.bool, wybe.comparison, wybe.int, wybe.io, wybe.string, wybe.char
use wybe.control, wybe.c_string

representation is unsigned

## Constants

def bound_minimum:_ = 0:_
def bound_maximum:_ = 18_446_744_073_709_551_615:_

# Overloaded versions based on an argument
def bound_minimum(x:_):_ = bound_minimum
def bound_maximum(x:_):_ = bound_maximum


## Common count operations

# Addition.  This operation is reversible:  you can compute either argument from
# the other argument and the value. However, as a count cannot be negative, some
# values may fail.
pub def (x:_ + y:_):_ = foreign llvm add(x,y)
pub def {partial} (?x:_ + y:_):_ = ?z where {
    z >= y
    ?x = foreign llvm sub(z,y)
}
pub def {partial} (x:_ + ?y:_):_ = ?z where {
    z >= x
    ?y = foreign llvm sub(z,x)
}

# Addition assignment.
pub def (!x:_ += y:_) { ?x = x + y }

# Subtraction.  This operation is reversible:  you can compute either argument
# from the other argument and the value. However, as a count cannot be negative, 
# some values may fail.
pub def {partial} (x:_ - y:_):_ = foreign llvm sub(x,y) where { y >= x }
pub def (?x:_ - y:_):_ = ?z where { ?x = foreign llvm add(z,y) }
pub def (x:_ - ?y:_):_ = ?z where { ?y = foreign llvm sub(z,x) }

# Subtraction assignment.
pub def {partial} (!x:_ -= y:_) { ?x = x - y }

# Multiplication.
pub def (x:_ * y:_):_ = foreign llvm mul(x,y)

# Multiplication assignment.
pub def (!x:_ *= y:_) { ?x = x * y }

# Division.
pub def (x:_ / y:_):_ = foreign llvm udiv(x,y)

# Division assignment.
pub def (!x:_ /= y:_) { ?x = x / y }

# Modulus.
pub def (x:_ % y:_):_ = foreign llvm urem(x,y)

# Modulus assignment.
pub def (!x:_ %= y:_) { ?x = x % y }

# Bit-shift left.
pub def (x:_ << s:_):_ = foreign llvm shl(x, s)

# Bit-shift left assignment.
pub def (!x:_ <<= s:_) { ?x = x << s }

# Logical bit-shift right (pad with zeroes).
# e.g.  3 >> 1 = 1                   (00...011 >> 1 = 00...001)
#      -3 >> 1 = 9223372036854775806 (11...101 >> 1 = 01...110)
# on a 64-bit machine
pub def logical_bitshift(x:_, s:_):_ = foreign llvm lshr(x, s)

# Bit-wise xor.
pub def xor(x:_, y:_):_ = foreign llvm xor(x, y)

# Bit-wise and.
pub def and(x:_, y:_):_ = foreign llvm and(x, y)

# Logarithm base 2.
pub def log2(x:_):_ =
    if {
        x <= 1:_ ::
            0:_
    |   else ::
            1:_ + log2(logical_bitshift(x, 1:_))
    }

## Comparisons

# Equality and disequality.
pub def {test} (x:_ =  y:_) { foreign llvm {test} icmp_eq(x,y) }
pub def {test} (x:_ ~= y:_) { foreign llvm {test} icmp_ne(x,y) }

# Inequalities.
pub def {test} (x:_ <  y:_) { foreign llvm {test} icmp_ult(x,y) }
pub def {test} (x:_ <= y:_) { foreign llvm {test} icmp_ule(x,y) }
pub def {test} (x:_ >  y:_) { foreign llvm {test} icmp_ugt(x,y) }
pub def {test} (x:_ >= y:_) { foreign llvm {test} icmp_uge(x,y) }

# Three-way comparison.
pub def (x:_ <=> y:_):comparison = 
    if { x < y :: lesser | x = y :: equal | else :: greater }

# Minimum and maximum of two counts.
pub def min(x:_, y:_):_ = if {x<=y:: x | else:: y}
pub def max(x:_, y:_):_ = if {x>=y:: x | else:: y}

# Conversion (this is lossy:  it can produce negative numbers!)
def int(x:_):int = foreign lpvm cast(x)


## Other

# Increment.
pub def incr(!x:_) { ?x = x + 1:_ }

# Decrement.
pub def {partial} decr(!x:_) { ?x = x - 1:_ }

## Formatting
pub def fmt(x:_):string = s where
    { ?s = (if {x >= 10:_ :: fmt(x/10:_) | else :: ""})
           ,, ( chr(ord('0')+int(x%10:_)) | shouldnt )
    }


## I/O

pub def print(x:_) use !io { foreign c print_count(x, !io) }

pub def println(x:_) use !io { !print(x); !nl }

pub def read(?x:_) use !io { foreign c read_count(?x, !io) }
