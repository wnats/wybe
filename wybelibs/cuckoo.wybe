constructor (V) cuckoo(table:table(V), item_count:count, rehash_count:count)

use db, logging

type table (T) {
    pub table(length:count, raw_data:raw_array)

    pub def WORD_SIZE_BYTES:count = foreign lpvm cast(word_size_bytes)

    pub def N_TABLE:count = 2:count

    def TABLE_SIZES = [17:count, 37:count]
    #|
    def TABLE_SIZES = [17:count,
                       37:count,
                       79:count,
                       163:count,
                       331:count,
                       673:count,
                       1361:count,
                       2729:count,
                       5471:count,
                       10949:count,
                       21911:count,
                       43853:count,
                       87719:count,
                       175447:count,
                       350899:count,
                       701819:count,
                       1403641:count,
                       2807303:count,
                       5614657:count,
                       11229331:count,
                       22458671:count,
                       44917381:count,
                       89834777:count,
                       179669557:count,
                       359339171:count]
    |#

    def next_prime(cur:count):count = nxt where {
        ?nxt = 0:count
        for ?size in TABLE_SIZES {
            if {
                size > cur ::
                    ?nxt = size
                    break
            |   else ::
                    ?nxt = nxt
            }
        }
        if { nxt = 0:count :: !error("Cuckoo: Ran out of prime table sizes") }
    }
    
    pub def empty_table(len:count):_(T) = tab where {
        ?size = len * WORD_SIZE_BYTES * N_TABLE
        foreign lpvm alloc(size, ?data)
        ?offset = 0:count
        do {
            while offset < size
            foreign lpvm mutate(data, ?data, offset, 1, size, 0, foreign lpvm cast(EMPTY))
            !offset += WORD_SIZE_BYTES
        }
        ?tab = table(len, data)
    }

    pub def resize_reset(!tab:_(T)) {
        ?tab = empty_table(next_prime(tab^length))
    }

    pub def get(tab:_(T), idx:count, ?val:T) use !db {
        foreign lpvm access(tab^raw_data, idx * WORD_SIZE_BYTES, WORD_SIZE_BYTES, 0, ?val, !db)
    }

    pub def set(tab:_(T), idx:count, val:T) use !db {
        foreign lpvm unsafe_mutate(tab^raw_data, idx * WORD_SIZE_BYTES, val, !db)
    }

    pub def print_table(tab:_(T), val2key:{resource}(T,?K), printer:{resource}(K)) use !io, !db {
        !println("Cuckoo Table:")
        ?len = foreign lpvm cast(tab^length)

        for ?i in 0..len*2 {
            !print(i % len)
            !print(": ")
            !get(tab, foreign lpvm cast(i), ?val)
            if {
                foreign lpvm cast(val) = EMPTY :: !println("NULL")
            |   else :: !val2key(val, ?key); !printer(key); !nl
            }
        }
    }
}

def get(cuckoo:_(V), idx:count, ?val:V) use !db {
    !get(cuckoo^table, idx, ?val)
}

def set(cuckoo:_(V), idx:count, val:V) use !db {
    !set(cuckoo^table, idx, val)
}

def length(cuckoo:_(V)):count = cuckoo^table^length

def resize_reset(!cuckoo:_(V)) {
    resize_reset(!cuckoo^table)
    !cuckoo^item_count = 0:count
}

def get_vals(cuckoo:_(V), ?vals:array(V)) use !db {
    ?data = cuckoo^table^raw_data
    ?i = 0
    ?vals = array(foreign lpvm cast(EMPTY):V, foreign lpvm cast(cuckoo^item_count))
    ?raw = vals^raw_data
    for ?idx in 0..foreign lpvm cast(N_TABLE*cuckoo^table^length) {
        !get(cuckoo, foreign lpvm cast(idx), ?val)
        unless foreign lpvm cast(val) = EMPTY
        foreign lpvm mutate(raw, ?raw, i * word_size_bytes, 1,
                            vals^length * word_size_bytes , 0, val)
        incr(!i)
    }
    !vals^raw_data = raw
}

# Constants
def EMPTY = 0:count
pub def INITIAL_TABLE_SIZE:count = 17:count

pub def cuckoo(size:count):_(V) =
    cuckoo(empty_table(size), 0:count, 0:count)

def {noinline} try_insert(cuckoo:_(V), val2key:{resource}(V,?K), hash:{resource}(K,count,?count), !val:V) use !db {
    ?eviction = 0:count
    ?i_tab = 0:count
    ?tab_len = cuckoo^length
    ?max_eviction = log2(tab_len) + 10:count
    do {
        while eviction <= max_eviction
        
        # compute the hash location
        !val2key(val, ?key)
        !hash(key, cuckoo^rehash_count*2:count + i_tab, ?h_key)
        ?idx = tab_len * i_tab + h_key % tab_len

        # evict the current resident of the hash location
        !get(cuckoo, idx, ?vic)
        !set(cuckoo, idx, val)

        # Prepare for the next eviction cycle (if eviction happens on this cycle)
        ?val = vic
        until foreign lpvm cast(vic) = EMPTY
        incr(!eviction)
        ?i_tab = (i_tab + 1:count) % N_TABLE
    }
}

pub def {noinline} insert(!cuckoo:_(V), val2key:{resource}(V,?K), hash:{resource}(K,count,?count), val:V) use !db {
    !try_insert(cuckoo, val2key, hash, !val)
    if {
        foreign lpvm cast(val) ~= EMPTY ::
            !rehash(!cuckoo, val2key, hash, val)
    }
    incr(!cuckoo^item_count)
}

def {noinline} rehash(!cuckoo:_(V), val2key:{resource}(V,?K), hash:{resource}(K,count,?count), evicted:V) use !db {
    !get_vals(cuckoo, ?vals)

    do {
        resize_reset(cuckoo)
        incr(!cuckoo^rehash_count)


        ?val = evicted
        !try_insert(!cuckoo, val2key, hash, !val)
        for ?val in vals {
            !try_insert(!cuckoo, val2key, hash, !val)
            while foreign lpvm cast(val) = EMPTY
            incr(!cuckoo^item_count)
        }
        
        until foreign lpvm cast(val) = EMPTY
    }
}

pub def {noinline} lookup(cuckoo:_(V), val2key:{resource}(V,?K), hash:{resource}(K,count,?count), eq:{test}(K,K), key:K, ?res:V) use !db {
    ?tab_len = cuckoo^length
    ?res = foreign lpvm cast(EMPTY)

    for ?i_tab in 0..foreign lpvm cast(N_TABLE) {
        # Compute the hash index
        !hash(key, cuckoo^rehash_count*2:count + foreign lpvm cast(i_tab), ?h_key)
        ?idx = tab_len * foreign lpvm cast(i_tab) + h_key % tab_len

        # Check if the key is equal
        !get(cuckoo, idx, ?val)
        unless foreign lpvm cast(val) = EMPTY
        !val2key(val, ?cand_key)

        if {
            eq(cand_key, key) ::
                ?res = val
                break
        |   else ::
                ?res = res
        }
    }
}

pub def {noinline} pop(!cuckoo:_(V), val2key:{resource}(V,?K), hash:{resource}(K,count,?count), eq:{test}(K,K), key:K, ?res:V) use !db {
    ?tab_len = cuckoo^length
    ?res = foreign lpvm cast(EMPTY)

    for ?i_tab in 0..foreign lpvm cast(N_TABLE) {
        # Compute the hash index
        !hash(key, cuckoo^rehash_count*2:count + foreign lpvm cast(i_tab), ?h_key)
        ?idx = tab_len * foreign lpvm cast(i_tab) + h_key % tab_len

        # Check if the key is equal
        !get(cuckoo, idx, ?val)
        unless foreign lpvm cast(val) = EMPTY
        !val2key(val, ?cand_key)

        if {
            eq(cand_key, key) ::
                ?res = val
                !set(cuckoo, idx, foreign lpvm cast(EMPTY))
                break
        |   else ::
                ?res = res
        }
    }
}

pub def {noinline} delete(!cuckoo:_(V), val2key:{resource}(V,?K), hash:{resource}(K,count,?count), eq:{test}(K,K), key:K) use !db {
    ?tab_len = cuckoo^length

    for ?i_tab in 0..foreign lpvm cast(N_TABLE) {
        # Compute the hash index
        !hash(key, cuckoo^rehash_count*2:count + foreign lpvm cast(i_tab), ?h_key)
        ?idx = tab_len * foreign lpvm cast(i_tab) + h_key % tab_len

        # Check if the key is equal
        !get(cuckoo, idx, ?val)
        unless foreign lpvm cast(val) = EMPTY
        !val2key(val, ?cand_key)
        if {
            eq(cand_key, key) :: 
                !set(cuckoo, idx, foreign lpvm cast(EMPTY))
                break
        }
    }
}

pub def {noinline} entity_insert(!cuckoo:_(V), val2key:{resource}(V,?K), hash:{resource}(K,count,?count), eq:{test}(K,K), ety:V, set_next:{resource}(V,V)) use !db {
    !val2key(ety, ?key)
    !pop(!cuckoo, val2key, hash, eq, key, ?res)
    !set_next(ety, res)
    !insert(!cuckoo, val2key, hash, ety)
}

pub def {noinline} entity_delete(!cuckoo:_(V), val2key:{resource}(V,?K), hash:{resource}(K,count,?count), eq:{test}(K,K), ety:V, get_next:{resource}(V,?V), set_next:{resource}(V,V)) use !db {
    !val2key(ety, ?key)
    !lookup(cuckoo, val2key, hash, eq, key, ?res)
    if {
        foreign lpvm cast(res):count = foreign lpvm cast(ety):count ::
            !get_next(ety, ?nxt)
            !delete(!cuckoo, val2key, hash, eq, key)
            if {
                foreign lpvm cast(nxt):count ~= 0:count ::
                    !insert(!cuckoo, val2key, hash, nxt)
            }
    |   else ::
            ?prv = res
            do {
                !get_next(prv, ?cur)
                until foreign lpvm cast(cur):count = foreign lpvm cast(ety):count
                ?prv = cur
            }
            !get_next(cur, ?nxt)
            !set_next(prv, nxt)
    }
}

pub def {noinline} print_table(cuckoo:_(V), val2key:{resource}(V,?K), printer:{resource}(K)) use !io, !db {
    !print_table(cuckoo^table, val2key, printer)
}

#|
# General Hashing
?cuck = cuckoo(1:count)
?val2key = {resource}{?@2:int = foreign lpvm cast(@1:count)}
!insert(!cuck, val2key, hash, 4:count)
!insert(!cuck, val2key, hash, 2:count)
!insert(!cuck, val2key, hash, 3:count)
!print_table(cuck, val2key, print)

!lookup(cuck, val2key, hash, `=`, 4, ?res)
!println("lookup(4): $res")

!lookup(cuck, val2key, hash, `=`, 2, ?res)
!println("lookup(2): $res")

!lookup(cuck, val2key, hash, `=`, 3, ?res)
!println("lookup(3): $res")

# Entity Hashing
!set_random_seed(17)
!generate_lookup_table

type ll {
    pub constructor node(val:int, nxt:_)
}

def get_val(a:ll, ?val:int) use !db {
    foreign lpvm access(a, 0, 16, 0, ?val, !db)
}

def get_next(a:ll, ?b:ll) use !db {
    foreign lpvm access(a, 8, 16, 0, ?b, !db)
}

def set_next(a:ll, b:ll) use !db {
    foreign lpvm unsafe_mutate(a, 8, b, !db)
}

def val2key(val:ll, ?key:int) use !db {
    !get_val(val, ?v)
    ?key = v % 2
}

?ll_null = foreign lpvm cast(0):ll
?n0:ll = node(0, ll_null)
?n1:ll = node(2, ll_null)
?n2:ll = node(4, ll_null)
?n3:ll = node(6, ll_null)

?cuck = cuckoo(17:count)

!entity_insert(!cuck, val2key, hash, `=`, n0, set_next)
!entity_insert(!cuck, val2key, hash, `=`, n1, set_next)
!entity_insert(!cuck, val2key, hash, `=`, n2, set_next)
!entity_insert(!cuck, val2key, hash, `=`, n3, set_next)

!print_table(cuck, get_val, print)


!entity_delete(!cuck, val2key, hash, `=`, n2, get_next, set_next)

!print_table(cuck, get_val, print)

?cur = n3
do {
    until foreign lpvm cast(cur):count = foreign lpvm cast(0):count
    !get_val(cur, ?val)
    !println(val)
    !get_next(cur, ?cur)
}
|#
