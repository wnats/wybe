# purpose: Cuckoo Hashing for Fast Entity Insertion/Lookup
# since  : 0.1

pub use db

################################################################
## PUBLIC INTERFACE
################################################################

# Return an empty cuckoo table with the default size of INITIAL_TABLE_SIZE
pub def cuckoo(?tab:_(V)) use !db {
    !cuckoo(INITIAL_TABLE_SIZE, ?tab)
}

# Return an empty cuckoo table with the specified size
pub def cuckoo(size:count, ?tab:_(V)) use !db {
    !empty_table(size, ?arr)
    ?tab = cuckoo(arr, 0:count, 0:count)
}

# Insert `val` to `cuckoo` where `val2key` maps a value to its key and
# `hash` is `cuckoo`'s hash function which hashes a key to some count
pub def {noinline} insert(!cuckoo:_(V), val2key:{resource}(V,?K),
                          hash:{resource}(K,count,?count), val:V) use !db {
    !try_insert(cuckoo, val2key, hash, !val)
    if {
        foreign lpvm cast(val) ~= EMPTY ::
            !rehash(!cuckoo, val2key, hash, val)
    }
    incr(!cuckoo^item_count)
}

# Find `res` which is a value corresponding to `key` in `cuckoo`
pub def {noinline} lookup(cuckoo:_(V), val2key:{resource}(V,?K),
                          hash:{resource}(K,count,?count), eq:{test}(K,K),
                          key:K, ?res:V) use !db {
    ?tab_len = cuckoo^length
    ?res = foreign lpvm cast(EMPTY)

    for ?i_tab in 0..foreign lpvm cast(N_TABLE) {
        # Compute the hash index
        !hash(key, cuckoo^rehash_count*N_TABLE + foreign lpvm cast(i_tab),
              ?h_key)
        ?idx = tab_len * foreign lpvm cast(i_tab) + h_key % tab_len

        # Check if the key is equal
        !get(cuckoo, idx, ?val)
        unless foreign lpvm cast(val) = EMPTY
        !val2key(val, ?cand_key)

        if {
            eq(cand_key, key) ::
                ?res = val
                break
        |   else ::
                ?res = res
        }
    }
}

# Find `res` which is a value corresponding to `key` in `cuckoo` and if
# is present, removes it from `cuckoo`.
pub def {noinline} pop(!cuckoo:_(V), val2key:{resource}(V,?K),
                       hash:{resource}(K,count,?count), eq:{test}(K,K),
                       key:K, ?res:V) use !db {
    ?tab_len = cuckoo^length
    ?res = foreign lpvm cast(EMPTY)

    for ?i_tab in 0..foreign lpvm cast(N_TABLE) {
        # Compute the hash index
        !hash(key, cuckoo^rehash_count*N_TABLE + foreign lpvm cast(i_tab),
              ?h_key)
        ?idx = tab_len * foreign lpvm cast(i_tab) + h_key % tab_len

        # Check if the key is equal
        !get(cuckoo, idx, ?val)
        unless foreign lpvm cast(val) = EMPTY
        !val2key(val, ?cand_key)

        if {
            eq(cand_key, key) ::
                ?res = val
                !set(cuckoo, idx, foreign lpvm cast(EMPTY))
                break
        |   else ::
                ?res = res
        }
    }
}

# Delete the value corresponding to `key` from `cuckoo`, if it exists
pub def {noinline} delete(!cuckoo:_(V), val2key:{resource}(V,?K),
                          hash:{resource}(K,count,?count), eq:{test}(K,K),
                          key:K) use !db {
    ?tab_len = cuckoo^length

    for ?i_tab in 0..foreign lpvm cast(N_TABLE) {
        # Compute the hash index
        !hash(key, cuckoo^rehash_count*N_TABLE + foreign lpvm cast(i_tab),
              ?h_key)
        ?idx = tab_len * foreign lpvm cast(i_tab) + h_key % tab_len

        # Check if the key is equal
        !get(cuckoo, idx, ?val)
        unless foreign lpvm cast(val) = EMPTY
        !val2key(val, ?cand_key)
        if {
            eq(cand_key, key) :: 
                !set(cuckoo, idx, foreign lpvm cast(EMPTY))
                break
        }
    }
}

# Insert an entity `ety` into `cuckoo`, chaining `ety` to `ety0` stored in
# `cuckoo` if such exists where `eq(val2key(ety0), val2key(ety1))` succeeds
pub def {noinline} entity_insert(!cuckoo:_(V), val2key:{resource}(V,?K),
                                 hash:{resource}(K,count,?count),
                                 eq:{test}(K,K), ety:V,
                                 set_next:{resource}(V,V)) use !db {
    !val2key(ety, ?key)
    !pop(!cuckoo, val2key, hash, eq, key, ?ety0)
    !set_next(ety, ety0)
    !insert(!cuckoo, val2key, hash, ety)
}

# Remove an entity `ety` from `cuckoo`, if it is stored, and replace it with
# ety_next where `!get_next(ety, ?ety_next)` holds.
# Otherwise, there should exist `ety0` (~= `ety`) where
# `eq(val2key(ety0), val2key(ety1))` succeeds, remove `ety` from `ety0`'s
# entity chain
pub def {noinline} entity_delete(!cuckoo:_(V), val2key:{resource}(V,?K),
                                 hash:{resource}(K,count,?count),
                                 eq:{test}(K,K), ety:V,
                                 get_next:{resource}(V,?V),
                                 set_next:{resource}(V,V)) use !db {
    !val2key(ety, ?key)
    !lookup(cuckoo, val2key, hash, eq, key, ?ety0)
    if {
        foreign lpvm cast(ety0):count = foreign lpvm cast(ety):count ::
            # `ety` is stored in `cuckoo`
            !get_next(ety, ?ety_next)
            !delete(!cuckoo, val2key, hash, eq, key)
            if {
                foreign lpvm cast(ety_next):count ~= 0:count ::
                    !insert(!cuckoo, val2key, hash, ety_next)
            }
    |   else ::
            ?prv = ety0
            do {
                !get_next(prv, ?cur)
                until foreign lpvm cast(cur):count = foreign lpvm cast(ety)
                ?prv = cur
            }
            !get_next(cur, ?nxt)
            !set_next(prv, nxt)
    }
}

# Print the cuckoo table
pub def {noinline} print_table(cuckoo:_(V), val2key:{resource}(V,?K),
                               printer:{resource}(K)) use !io, !db {
    !print_table(cuckoo^table, val2key, printer)
}

################################################################
## PRIVATE INTERFACE
################################################################

constructor (V) cuckoo(table:table(V), item_count:count, rehash_count:count)

# A special array using the db resource for destructive updates, which is
# necessary for a hash table
type table (T) {
    pub table(length:count, raw_data:raw_array)

    pub def WORD_SIZE_BYTES:count = foreign lpvm cast(word_size_bytes)

    # By default a cuckoo table has two tables
    pub def N_TABLE:count = 2:count

    pub def EMPTY:count = 0:count

    # The table sizes are hardcoded to be prime numbers that double each time
    def TABLE_SIZES = [17:count,
                       37:count,
                       79:count,
                       163:count,
                       331:count,
                       673:count,
                       1361:count,
                       2729:count,
                       5471:count,
                       10949:count,
                       21911:count,
                       43853:count,
                       87719:count,
                       175447:count,
                       350899:count,
                       701819:count,
                       1403641:count,
                       2807303:count,
                       5614657:count,
                       11229331:count,
                       22458671:count,
                       44917381:count,
                       89834777:count,
                       179669557:count,
                       359339171:count]

    # Find the next table size from cur
    def next_table_size(cur:count):count = nxt where {
        ?nxt = 0:count
        for ?size in TABLE_SIZES {
            if {
                size > cur ::
                    ?nxt = size
                    break
            |   else ::
                    ?nxt = nxt
            }
        }
        if { nxt = 0:count :: !error("Cuckoo: Ran out of prime table sizes") }
    }
    
    # Return an empty cuckoo table of size len
    pub def empty_table(len:count, ?tab:_(T)) use !db {
        ?size = len * WORD_SIZE_BYTES * N_TABLE
        foreign lpvm alloc(size, ?data)
        ?offset = 0:count
        do {
            while offset < size
            foreign lpvm unsafe_mutate(data, offset, foreign lpvm cast(EMPTY), !db)
            !offset += WORD_SIZE_BYTES
        }
        ?tab = table(len, data)
    }

    # Increase the size of tab and empty it
    pub def next_size_empty(!tab:_(T)) use !db {
        !empty_table(next_table_size(tab^length), ?tab)
    }

    # val is the value stored at the idx position of tab
    pub def get(tab:_(T), idx:count, ?val:T) use !db {
        foreign lpvm access(tab^raw_data, idx * WORD_SIZE_BYTES,
                            WORD_SIZE_BYTES, 0, ?val, !db)
    }

    # Mutate the idx position of tab
    pub def set(tab:_(T), idx:count, val:T) use !db {
        foreign lpvm unsafe_mutate(tab^raw_data, idx * WORD_SIZE_BYTES, val, !db)
    }

    # Print tab
    pub def print_table(tab:_(T), val2key:{resource}(T,?K),
                        printer:{resource}(K)) use !io, !db {
        !println("Cuckoo Table:")
        ?len = foreign lpvm cast(tab^length)
        ?n_table = foreign lpvm cast(N_TABLE)

        for ?i in 0..len*n_table {
            !print("$(i % len): ")
            !get(tab, foreign lpvm cast(i), ?val)
            if {
                foreign lpvm cast(val) = EMPTY :: !println("NULL")
            |   else :: !val2key(val, ?key); !printer(key); !nl
            }
        }
    }
}

# The initial table size
def INITIAL_TABLE_SIZE:count = 17:count

# val is the value stored at the idx position of cuckoo
def get(cuckoo:_(V), idx:count, ?val:V) use !db {
    !get(cuckoo^table, idx, ?val)
}

# Mutate the idx position of cuckoo
def set(cuckoo:_(V), idx:count, val:V) use !db {
    !set(cuckoo^table, idx, val)
}

# Return the length of the cuckoo table
def length(cuckoo:_(V)):count = cuckoo^table^length

# Increase the size of tab and empty it
def next_size_empty(!cuckoo:_(V)) use !db {
    !next_size_empty(!cuckoo^table)
    !cuckoo^item_count = 0:count
}

# vals is an array of values stored in cuckoo
def cuckoo_vals(cuckoo:_(V), ?vals:array(V)) use !db {
    ?data = cuckoo^table^raw_data
    ?i = 0
    ?vals = array(foreign lpvm cast(EMPTY):V,
                  foreign lpvm cast(cuckoo^item_count))
    ?raw = vals^raw_data
    for ?idx in 0..foreign lpvm cast(N_TABLE*cuckoo^table^length) {
        !get(cuckoo, foreign lpvm cast(idx), ?val)
        unless foreign lpvm cast(val) = EMPTY
        foreign lpvm mutate(raw, ?raw, i * word_size_bytes, 1,
                            vals^length * word_size_bytes , 0, val)
        incr(!i)
    }
    !vals^raw_data = raw
}

# Try to insert val into cuckoo
# If it succeeds val will be EMPTY
# Otherwise, val will store the last evicted value before the cuckoo loop
# terminates
def {noinline} try_insert(cuckoo:_(V), val2key:{resource}(V,?K),
                          hash:{resource}(K,count,?count), !val:V) use !db {
    ?eviction = 0:count
    ?i_tab = 0:count
    ?tab_len = cuckoo^length

    # Approximate value when we can be somewhat confident we have an
    # irreconcilable collision in the cuckoo table
    ?max_eviction = log2(tab_len) + 10:count

    do {
        while eviction <= max_eviction
        
        # Compute the hash location
        !val2key(val, ?key)
        !hash(key, cuckoo^rehash_count*N_TABLE + i_tab, ?h_key)
        ?idx = tab_len * i_tab + h_key % tab_len

        # Evict the current resident of the hash location
        !get(cuckoo, idx, ?vic)
        !set(cuckoo, idx, val)

        # Prepare for the next eviction cycle
        ?val = vic
        until foreign lpvm cast(vic) = EMPTY
        incr(!eviction)
        ?i_tab = (i_tab + 1:count) % N_TABLE
    }
}

# Rehash the elements of cuckoo + evicted
def {noinline} rehash(!cuckoo:_(V), val2key:{resource}(V,?K),
                      hash:{resource}(K,count,?count), evicted:V) use !db {
    !cuckoo_vals(cuckoo, ?vals)

    do {
        !next_size_empty(!cuckoo)
        incr(!cuckoo^rehash_count)

        ?val = evicted
        !try_insert(!cuckoo, val2key, hash, !val)
        for ?val in vals {
            !try_insert(!cuckoo, val2key, hash, !val)
            while foreign lpvm cast(val) = EMPTY
            incr(!cuckoo^item_count)
        }
        
        until foreign lpvm cast(val) = EMPTY
    }
}
